---
layout: post
title: "Redis: Remote Dictionary Server"
subtitle: "Максимальная скорость доступа к данным"
date: 2020-01-02 17:37:00 +0300
background: '/img/posts/redis-compressor.jpg'
---
# Redis: Что за зверь?

[Redis](https://redis.io/) - Своего рода база данных (NoSQL) работающая с Key-Value структурой (чаще всего, но 
поддерживаются и иные структуры данных), 
написан на языке С (Си), является приложением с открытым исходных кодом(BSD licensed). Все данных хранятся в 
оперативной памяти, что позволяет добиться крайне высокой скорости I/O. Как правило используется в качестве:
- Брокера сообщений - Является отличным аналогом [Rabbitmq](https://www.rabbitmq.com/) 
и [Kafka](https://kafka.apache.org/)
- Очереди сообщений 
- Управления сеансами(Например JSON Web Token)
- Базы данных(самый редкий вариант) 
- Многое другое

#### Redis: Как это работает?
Все данные хранятся в оперативной памяти системы, поскольку это исключает обращения к жесткому диску, скорость без 
преувеличения можно назвать "молниеносной".

#### Производительность
Забегая немного вперед хочется 
сказать что `redis` содержит в своем "комплекте поставки" `redis-benchmark`, запустим тест:
 
```shell script
$ redis-benchmark -t set,lpush -n 100000 -q
SET: 74239.05 requests per second
LPUSH: 79239.30 requests per second
``` 

- `redis-benchmark` - Исполняемая команда 
- `-t` - `SET,lpush` Перечень запускаемых тестов, разделенная запятыми 
- `-n` - Количество элементов в тесте
- `-q` - Тихий режим, подавляет output и выводит лишь конечный результат в виде `запросов/в секунду`

Однако даже тут имеются "узкие места"(В порядке важности): 
- Сеть - Пропускная способность и задержки в сети являются основным фактором влияющим на скорость.
- Процессор - Так как Redis является однопоточным приложением, предпочтение стоит отдавать процессорам с наименьшим 
количеством потоков и наибольшим кэшем.
- Скорость Оперативной памяти и пропускная способность памяти кажутся менее важными для глобальной производительности.

#### Преимущества

##### Репликация и Шардирование

Redis можно ""размазать" на кластер путем репликации (дублирования) или шардирования (сегментирование), возможно
использование двух подходов одновременно что позволяет максимально повысить надежность хранения данных и обеспечить 
отказоустойчивость, но не стоит забывать о том что каждый из подходов налагает свои минусы: 

`Replication` - Увеличить скорость операция "Чтения".

`Sharding`  - Увеличить скорость операция "Запись".

##### Гибкие структуры данных
В отличие от упрощенных хранилищ на основе пар «ключ – значение», которые поддерживают ограниченный набор структур 
данных, Redis поддерживает огромное разнообразие структур данных, позволяющее удовлетворить потребности разнообразных
приложений. Типы данных Redis включают:

- строки – текстовые или двоичные данные размером до 512 МБ;
- списки – коллекции строк, упорядоченные в порядке добавления;
- множества – неупорядоченные коллекции строк с возможностью пересечения, объединения и сравнения с другими типами множеств;
- сортированные множества – множества, упорядоченные по значению;
- хэш‑таблицы – структуры данных для хранения списков полей и значений;
- битовые массивы – тип данных, который дает возможность выполнять операции на уровне битов;
- структуры HyperLogLog – вероятностные структуры данных, служащие для оценки количества уникальных элементов в наборе данных.


#### От теории к практике

Наиболее простым вариантом "поиграться" с Redis считаю Docker, надеюсь он у вас имеется, если нет, я бы 
советовал воспользоваться [Docker песочницей](https://labs.play-with-docker.com/). 

Получаем образ Redis: 

```shell script
~# docker pull redis
...                                                                                                                                                                                                  da01136793fa: Pull complete                                                                                                                                                                                                                  cf1486a2c0b8: Pull complete                                                                                                                                                                                                                  a44f7da98d9e: Pull complete                                                                                                                                                                                                                  c677fde73875: Pull complete                                                                                                                                                                                                                  727f8da63ac2: Pull complete                                                                                                                                                                                                                  Digest: sha256:90d44d431229683cadd75274e6fcb22c3e0396d149a8f8b7da9925021ee75c30
Status: Downloaded newer image for redis:latest
``` 

Запускаем Redis:

```shell script
~# ~# docker run --rm --name my-redis-name -d redis
```

Для тех кто не знаком с Docker, немного поясню происходящие: 

`docker` - Исполняющий файл

`run` - Запуск образа который мы скачали в предыдущем шаге

`--rm` - После остановки, контейнер будет удален чтобы не "мусорить" системе

`--name` - Задаем некое читаемое имя для контейнера, эта информация исключительно для людей и можно записать что угодно

`-d` - Просим запустить контейнер в фоне и напечатать нам лишь его ID

Проверим состояние нашего контейнера и убедимся что все работает должным образом: 

```shell script
~# docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
2b01a01e4a35        redis               "docker-entrypoint.s…"   7 seconds ago       Up 5 seconds        6379/tcp            my-redis-name
```

Если вы видите в списке `my-redis-name` значит Redis запущен и готов к работе. Далее подключаемся клиентом к нашему
серверу Redis:

```shell script
~# docker exec -it my-redis-name redis-cli
127.0.0.1:6379>
```

Несколько команд для примера:

```shell script
127.0.0.1:6379> set country russia
OK
127.0.0.1:6379> get country
"russia"
127.0.0.1:6379> incr counter
(integer) 1
127.0.0.1:6379> incr counter
(integer) 2
127.0.0.1:6379> get counter
"2"
127.0.0.1:6379>exit
``` 

Уточнения думаю тут излишни, так как команды предельно понятны и просты. После выхода из контейнера не забудьте его 
удалить: 

```shell script
~# docker rm -f my-redis-name
```

Больше подробностей и информации вы можете найти в [оффициальной документации](https://redis.io/documentation) 

Думаю в следующих статьях напишу о том как правильно выполнять реплицирование и шардирование и работу с иными 
структурами данных.